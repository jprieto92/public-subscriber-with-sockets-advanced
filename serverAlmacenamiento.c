/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include "almacenamientoTemas.h"

/*VARIABLES GLOBALES*/
pthread_mutex_t mutex;	        	// Mutex
pthread_cond_t espera;       		// Variables condicionales
int numeroLectores = 0;				// Numero de lectores en el sistema
int servicioArrancado = 0;

typedef struct topic{
	char nombre[129];	// Nombre del tema
	char text[10][1025];			// Lista de suscritos al tema 
	int textOcupados;				// Numero de suscritos al tema
	struct topic *next;
} topic;

topic *lista = NULL;

bool_t
init_1_svc(int i, int *result,  struct svc_req *rqstp)
{

	/*
	 * insert server code here
	 */
	/*INICIALIZAMOS MUTEX QUE CONTROLAN BASE DE DATOS*/
	pthread_mutex_init(&mutex, NULL);
	pthread_cond_init(&espera, NULL);
	servicioArrancado = 1;

	*result = 0;

	return 1;
}

bool_t
putpair_1_svc(char *tema, char *texto, int *result,  struct svc_req *rqstp)
{
	if(servicioArrancado==0)
	{
		return -1;
	}
	topic *iterador;
	/*CONTROLAMOS CONCURRENCIA*/
	pthread_mutex_lock(&mutex);
	while(numeroLectores>0)	
	{
		pthread_cond_wait(&espera, &mutex);	// Si hay lectores, esperar
	}

	iterador = lista;
	if(iterador ==NULL)	// Lista vacia -- Primer elemento
	{
		iterador  = (topic *)malloc(sizeof(topic));
		strcpy((char *)iterador->nombre, (const char*) tema);
		strcpy((char *)iterador->text[0], (const char*) texto);
		iterador -> textOcupados = 1;
		lista = iterador;
		iterador -> next = NULL;
		/*FIN SECCION CRITICA*/
		pthread_mutex_unlock(&mutex);
		return 1;
	}else{			// Lista no vacia
		while(iterador)
		{
			if((strcmp((const char *)iterador->nombre,(const char *)tema)==0))	// Tema encontrado
			{
				strcpy((char *)iterador->text[(iterador -> textOcupados) % 10], (const char*) texto);
				iterador -> textOcupados = (iterador -> textOcupados + 1);
				/*FIN SECCION CRITICA*/
				pthread_mutex_unlock(&mutex);
				return 1;
			}
			if(iterador -> next == NULL)
			{
				iterador  = (topic *)malloc(sizeof(topic));
				strcpy((char *)iterador->nombre, (const char*) tema);
				strcpy((char *)iterador->text[0], (const char*) texto);
				iterador -> textOcupados = 1;
				lista = iterador;
				iterador -> next = NULL;
				/*FIN SECCION CRITICA*/
				pthread_mutex_unlock(&mutex);
				return 1;
			}
			iterador = iterador -> next;
		}
	}
	/*FIN SECCION CRITICA*/
	pthread_mutex_unlock(&mutex);
	return 1;
}

bool_t
gettexts_1_svc(char *tema, respTextos *result,  struct svc_req *rqstp)
{
	if(servicioArrancado==0)
	{
		return -1;
	}	
	topic *iterador;
	int i;

	/*CONTROLAMOS CONCURRENCIA*/
	pthread_mutex_lock(&mutex);
	while(numeroLectores>0)	
	{
		pthread_cond_wait(&espera, &mutex);	// Si hay lectores, esperar
	}

	iterador = lista;
	if(iterador ==NULL)	// Lista vacia -- Primer elemento
	{
		result -> textos = -1;
		result -> texto = (char *)malloc(10249);
		/*FIN SECCION CRITICA*/
		pthread_mutex_unlock(&mutex);
		return 1;
	}else{			// Lista no vacia
		while(iterador)
		{
			if((strcmp((const char *)iterador->nombre,(const char *)tema)==0))	// Tema encontrado
			{
				result -> texto = (char *)malloc(10249);
				if(iterador -> textOcupados < 10)
				{
					result -> textos = iterador -> textOcupados;
					strcpy(result->texto,iterador->text[0]);	
					for(i=1;i<iterador -> textOcupados;i++)
					{
						strcat(result->texto,":");
						strcat(result->texto,iterador->text[i]);
					}
				}else{
					result -> textos = 10;
					strcpy(result->texto,iterador->text[0]);	
					for(i=1;i<10;i++)
					{
						strcat(result->texto,":");
						strcat(result->texto,iterador->text[i]);
					}
				}
				/*FIN SECCION CRITICA*/
				pthread_mutex_unlock(&mutex);
				return 1;
			}
			iterador = iterador -> next;
		}
	}
	result -> textos = -1;
	result -> texto = (char *)malloc(10249);
	/*FIN SECCION CRITICA*/
	pthread_mutex_unlock(&mutex);
	return 1;
}

int
almacenamientotemas_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
